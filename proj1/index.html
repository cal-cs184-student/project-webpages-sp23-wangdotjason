<html>
	<head>
	</head>
	<body>
		<p>
			1. I rasterized my triangles by sampling points in the center of pixels and checking if the sample point was inside of a triangle. <br>
			If it was, then I colored that pixel in the frame_buffer. My algorithm is no worse than one that checks samples within the bounding <br>
			box of a triangle because my algorithm does exactly that, I did not implement sample checking for scanning only the points within <br>
			the edges of a triangle. <br>
		</p>
		<img src="q1.png" alt="Italian Trulli">
		<br>
		
		2. 
Show png screenshots of basic/test4.svg with the default viewing parameters and sample rates
		1, 4, and 16 to compare them side-by-side. Position the pixel inspector over 
		an area that showcases the effect dramatically; for example, a very skinny triangle corner. Explain why these results are observed.
		
		My supersampling algorithm scales the horizontal and vertical frequency of sampling and outputs to a sample buffer that is also scaled 
		the appropriate amount. Vertices of triangles, points, and lines are also scaled accordingly. For example a point at (1,2) would be mapped to 
		(4, 8) with 4x4 supersampling. This way I did not have to make many changes to my rasterization pipeline and could reuse code from part 1
		to conduct the sampling. After populating the sample buffer, each NxN group of pixels, where NxN is the supersampling frequency, 
		is averaged out and colored in the frame buffer. Supersampling is useful because it reduces the ammount of jaggies where a good portion of an object
		is within the viewing pixel, but does not pass through the sampling point. Essentially, supersampling is a heuristic for coloring pixels by area 
		without doing all the computation required to accurately calcuate area. 
		
		3.Create an updated version of svg/transforms/robot.svg with cubeman doing something more interesting, like waving or running. 
		Feel free to change his colors or proportions to suit your creativity. Save your svg file as my_robot.svg in your docs/ 
		directory and show a png screenshot of your rendered drawing in your write-up. Explain what you were trying to do with cubeman in words.
		Cubeman wave hi! :) 
		
		4.Explain barycentric coordinates in your own words and use an image to aid you in your explanation. 
		One idea is to use a svg file that plots a single triangle with one red, one green, and one blue vertex, 
		which should produce a smoothly blended color triangle.
Show a png screenshot of svg/basic/test7.svg with default viewing parameters and sample rate 1. If you make any additional images with color gradients, include them.
		Barycentric coordinates are coordinates used to describe points within a triangle where each coordinate is the relative distance between 
		a vertex and the opposing edge. 
		
		5.
		Explain pixel sampling in your own words and describe how you implemented it to perform texture mapping. Briefly discuss the two different pixel 
		sampling methods, nearest and bilinear.
Check out the svg files in the svg/texmap/ directory. Use the pixel inspector to find a good example of where bilinear sampling clearly defeats nearest sampling. 
		Show and compare four png screenshots using nearest sampling at 1 sample per pixel, nearest sampling at 16 samples per pixel, bilinear sampling at 1 sample per pixel, and bilinear sampling at 16 samples per pixel.
Comment on the relative differences. Discuss when there will be a large difference between the two methods and why.
		
		Pixel sampling is where pixels on an objects/shape are mapped to pixels in a texture map. Nearest pixel sampling is where the pixel sampled is the 
		closests pixel in the texture to the uv coordinate. Bilinear sampling is where the 4 pixels in the texture map around the uv coordinate 
		are sampled and averaged out using linear interpolation. 
		
		
		6.Explain level sampling in your own words and describe how you implemented it for texture mapping.
You can now adjust your sampling technique by selecting pixel sampling, level sampling, or the number of samples per pixel. 
		Describe the tradeoffs between speed, memory usage, and antialiasing power between the three various techniques.
Using a png file you find yourself, show us four versions of the image, using the combinations of L_ZERO and P_NEAREST, L_ZERO and 
		P_LINEAR, L_NEAREST and P_NEAREST, as well as L_NEAREST and P_LINEAR.
To use your own png, make a copy of one of the existing svg files in svg/texmap/ (or create your own modelled after one of the provided svg files). 
		Then, near the top of the file, change the texture filename to point to your own png. From there, you can run ./draw and pass 
		in that svg file to render it and then save a screenshot of your results.
Note: Choose a png that showcases the different sampling effects well. You may also want to zoom in/out, use the pixel inspector, etc. to 
		demonstrate the differences.
		
		Level sampling
		
		
	</body>
</html>
